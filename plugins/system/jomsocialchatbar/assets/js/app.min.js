(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
(function (global){
var store = require('./store');

// Initialize `joms` object if not found.
window.joms = window.joms || {};

window.joms.store = store;

(function( global, factory ) {

    if(!joms.getData( 'is_chat_view' )) { 
        joms_observer.add_action('chat_initialized', factory, 1, 1);
    }

})( window, function() {
    var Vue = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vue,
        Chatbar = require( './components/chatbar' ),
        store = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).store,
        app;

    app = new Vue({
        store: store,
        render: function( createElement ) {
            return createElement( Chatbar );
        },
        mounted: function() {
            var store = this.$store;

            store.dispatch( 'chats/fetch', joms.chat ).then( function() {

                _.each( joms.chat.conversations, function ( item ) {
                    store.dispatch( 'chats/addSidebarItem', item.id );
                })

                store.dispatch( 'chats/syncState' );
            });
        }
    }).$mount();

    // Append element to the document root.
    document.body.appendChild( app.$el );

    jQuery('body').on('click', function( e ) {
        var el = jQuery(e.target).parents('.joms-chatbar');
        if (!el.length) {
            joms.store.dispatch( 'chats/setActiveWindow', 0 );
        }
    });
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./components/chatbar":6,"./store":17}],2:[function(require,module,exports){
(function (global){
var Vue = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vue,
    localStore = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).storage,
    settings = window.joms_plg_jomsocialchatbar || {},
    configs = settings.configs || {},
    templates = settings.templates || {};

module.exports = Vue.component( 'chatbar-sidebar', {
    template: templates.chatbar_sidebar,
    data: function() {
        var data, state;

        data = {
            expanded: true,
            fetching: false,
            fetchDone: false
        };

        if ( +configs.remember_last_state ) {
            state = localStore.get( 'chatbar' ) || {};
            _.extend( data, state.sidebar || {} );
        }

        return data;
    },
    computed: {
        chats: function() {
            return this.$store.getters['chats/sidebar'];
        }
    },
    methods: {
        open: function( id ) {
            this.$store.dispatch( 'chats/open', id );
        },
        toggle: function() {
            var config = localStore.get( 'chatbar' ) || {},
                configSidebar = config.sidebar || {};

            this.expanded = ! this.expanded;
            _.extend( configSidebar, { expanded: this.expanded });
            _.extend( config, { sidebar: configSidebar });

            localStore.set( 'chatbar', config );
        },
        fetch: function(ids) {
            if ( ! this.fetching && ! this.fetchDone ) {
                this.fetching = true;
                this.fetchDebounced(ids);
            }
        },
        fetchDebounced: function(ids) {
            var that = this;
            this.$store.dispatch( 'chats/fetchMore', { list : ids } ).fail(function() {
                that.fetchDone = true;
            }).always(function() {
                that.fetching = false;
            });
        },
        handleScroll: function( e ) {
            var el = e.currentTarget,
                scrollTop = el.scrollTop,
                delta = e.deltaY,
                height;
            if ( scrollTop === 0 && delta < 0 ) {
                e.preventDefault();
                e.stopPropagation();
            } else {
                var items = el.querySelectorAll('.joms-chat__item');
                var ids = [];
                for (var i = 0; i < items.length; i++) {
                    ids.push(+items[i].getAttribute('data-id'));
                }
                height = el.scrollHeight - el.clientHeight;
                if ( Math.abs( scrollTop - height ) <= 1 && delta > 0 ) {
                    e.preventDefault();
                    e.stopPropagation();
                    if ( !this.fetchDone ) {
                        this.fetch(ids);
                    }
                }
            }
        },
        setActiveWindow: function( chat ) {
            this.$store.dispatch( 'chats/setActiveWindow', +chat.id );
            this.$store.dispatch( 'chats/open', +chat.id );
            if ( +chat.seen === 0 ) {
                this.$store.dispatch( 'chats/seen', +chat.id );
            }
        }
    }
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],3:[function(require,module,exports){
(function (global){
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null),
    joms = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null),
    autosize = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).autosize_textarea,
    Vue = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vue,
    user_id = String( window.joms_my_id || '' ),
    settings = window.joms_plg_jomsocialchatbar || {},
    templates = settings.templates || {};

module.exports = Vue.component( 'chatbar-window-input', {
    template: templates.chatbar_window_input,
    props: [ 'chat', 'active' ],
    data: function() {
        return {
            attachment: false,
            ta_original_height: ''
        };
    },
    mounted: function() {
        if (this.active) {
            this.focus();
        }
        autosize(this.$el.querySelector('textarea'));
        this.ta_original_height = this.$el.querySelector('textarea').style.height;
    },
    watch: {
        active: function( val ) {
            if (val) {
                this.focus();
            }
        }   
    },
    methods: {
        focus: function() {
            this.$el.querySelector('textarea').focus();
        },
        submit: function( event ) {
            var $input = event.target,
                timestamp = ( new Date ).getTime(),
                attachment = JSON.parse( JSON.stringify( this.attachment || {} ) ),
                data;
            
            if ($input.value.trim() || this.attachment) {
                data = {
                    chat_id: this.chat.id,
                    user_id: user_id,
                    action: 'sent',
                    content: $input.value,
                    attachment: attachment,
                    params: { attachment: attachment },
                    created_at: Math.floor( timestamp / 1000 )
                };

                $input.value = '';
                this.attachment = false;
                this.resetInputStyle($input);
                this.$emit( 'submit', data );
            }

        },

        resetInputStyle: function($el) {
            $el.style.height = this.ta_original_height;
            $el.style.overflow = 'hidden';
        },

        attachImage: function( e ) {
            var that = this,
                baseUrl = joms.getData( 'base_url' ),
                url = baseUrl + 'index.php?option=com_community&view=photos&task=ajaxPreviewComment',
                extensions = 'jpg,jpeg,png,gif';

            doUpload({
                url: url,
                filters: { mime_types: [{ title: 'Image files', extensions: extensions }] },
                max_file_size: undefined
            }).done(function( file, json ) {
                that.attachment = {
                    type: 'image',
                    id: json.photo_id,
                    url: json.thumb_url
                };
            });
        },
        attachFile: function( e ) {
            var that = this,
                baseUrl = joms.getData( 'base_url' ),
                url = baseUrl + 'index.php?option=com_community&view=files&task=multiUpload&type=chat&id' + this.chat.id,
                extensions = 'bmp,csv,doc,gif,ico,jpg,jpeg,odg,odp,ods,odt,pdf,png,ppt,swf,txt,xcf,xls,BMP,CSV,DOC,GIF,ICO,JPG,JPEG,ODG,ODP,ODS,ODT,PDF,PNG,PPT,SWF,TXT,XCF,XLS';

            doUpload({
                url: url,
                filters: { mime_types: [{ title: 'Document files', extensions: extensions }] },
                max_file_size: undefined
            }).done(function( file, json ) {
                that.attachment = {
                    type: 'file',
                    id: json.id,
                    url: json.path,
                    name: file.name
                };
            })
        },
        removeAttachment: function( e ) {
            this.attachment = false;
        }
    }
});


////////////////////////////////////////////////////////////////////////////////////////////////////
// FILE UPLOADER
////////////////////////////////////////////////////////////////////////////////////////////////////

var _uploader,
    _uploaderButton,
    _uploaderDefer;

function doUpload( settings ) {
    return $.Deferred(function( defer ) {
        initUpload( defer ).done(function( uploader, $button ) {
            uploader.refresh();
            uploader.settings.url = settings.url;
            uploader.settings.filters = settings.filters;
            uploader.settings.max_file_size = settings.max_file_size;
            uploader.refresh();
            $button.click();
        });
    });
}

function initUpload( defer ) {
    // Save defer object for later use.
    _uploaderDefer = defer;

    return $.Deferred(function( defer ) {
        if ( _uploader ) {
            defer.resolve( _uploader, _uploaderButton );
            return;
        }

        joms.util.loadLib( 'plupload', function() {
            setTimeout(function() {
                var id = 'joms-js--jomsocialchatbar-uploader',
                    url = joms.getData( 'base_url' ) + 'index.php?option=com_community',
                    $container, $button;

                $container = $( '<div id="' + id + '" aria-hidden="true" />' )
                    .css({ width: 1, height: 1, overflow: 'hidden' })
                    .appendTo( document.body );

                $button = $( '<button id="' + id + '-button" />' ).appendTo( $container );

                _uploader = new window.plupload.Uploader({
                    url: url,
                    container: id,
                    browse_button: id + '-button',
                    runtimes: 'html5,html4',
                    multi_selection: false
                });

                _uploader.bind( 'FilesAdded', function( up ) {
                    setTimeout(function() {
                        up.start();
                        up.refresh();
                    }, 1 );
                });

                _uploader.bind( 'Error', function( up, error ) {
                    window.alert( error && error.message || 'Undefined error.' );
                });

                _uploader.bind( 'FileUploaded', function( up, file, info ) {
                    var json, ct, loading, thumb, button, img, label;

                    try {
                        json = JSON.parse( info.response );
                    } catch ( e ) {}

                    json = json || {};

                    if ( json.error || json.msg ) {
                        window.alert( json.error || json.msg );
                        _uploaderDefer.reject();
                        return;
                    }

                    if ( ! ( ( json.thumb_url && json.photo_id ) || json.id ) ) {
                        window.alert( 'Undefined error.' );
                        _uploaderDefer.reject();
                        return;
                    }

                    _uploaderDefer.resolve( file, json );
                });

                _uploader.init();

                _uploaderButton = $container.find( 'input[type=file]' );
                defer.resolve( _uploader, _uploaderButton );
            });
        });
    });
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],4:[function(require,module,exports){
(function (global){
var Vue = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vue,
    USER_ID = +( window.joms_my_id || '' ),
    settings = window.joms_plg_jomsocialchatbar || {},
    templates = settings.templates || {};

module.exports = Vue.component( 'chatbar-window-search', {
    template: templates.chatbar_window_search,
    props: [ 'participants' ],
    data: function() {
        return {
            inputWidth: 10,
            queryResults: [],
            selectedIds: [],
            selectedNames: []
        };
    },
    computed: {
        selectedUsers: function() {
            return _.map( this.selectedIds, function( id, index ) {
                return { id: id, name: this.selectedNames[ index ] };
            }, this );
        },
    },
    mounted: function() {
        this.$input = this.$el.querySelector( '.joms-js-input' );
    },
    methods: {

        /**
         * Reset selected users.
         */
        reset: function() {
            this.selectedIds = [];
            this.selectedNames = [];
        },

        /**
         * Submit selected users.
         */
        add: function() {
            var selected = JSON.parse( JSON.stringify( this.selectedIds ) );
            this.$emit( 'done', selected );
            _.each( selected, function( id ) {
                this.participants.push( id );
            }, this );

            this.reset();
        },

        /**
         * Cancel select users.
         */
        cancel: function() {
            this.reset();
            this.$emit( 'hide' );
        },

        /**
         * Search users by keyword.
         * @param {string} keyword
         */
        search: function( keyword ) {
            var users = this.$store.getters[ 'users/search' ]( keyword ),
                filtered = this.filterSelected( users );

            this.queryResults = filtered;
        },

        /**
         * Select user.
         */
        select: function( id ) {
            var name;

            if ( this.selectedIds.indexOf( id ) === -1 ) {
                name = this.$store.getters[ 'users/name' ]( id );
                this.selectedIds.push( id );
                this.selectedNames.push( name );
                this.queryResults = [];
                this.$input.value = '';
                this.$input.focus();
            }
        },

        /**
         * Remove selected user.
         */
        removeSelected: function( id ) {
            var index = this.selectedIds.indexOf( +id );

            if ( index !== -1 ) {
                this.selectedIds.splice( index, 1 );
                this.selectedNames.splice( index, 1 );
                this.queryResults = this.filterSelected( this.queryResults );
            }
        },

        /**
         * Filter-out selected users for the list.
         * @param {Object[]} users
         */
        filterSelected: function( users ) {
            var participants = this.participants,
                selected = this.selectedIds;

            return _.filter( users, function( user ) {
                var id = +user.id,
                    allow = true;

                if ( id === USER_ID ) {
                    allow = false;
                } else if ( participants.indexOf( id ) > -1 ) {
                    allow = false;
                } else if ( selected.indexOf( id ) > -1 ) {
                    allow = false;
                }

                return allow;
            });
        },

        /**
         * Handle click on fake input.
         */
        onInputClick: function( e ) {
            this.$el.querySelector( '.joms-js-input' ).focus();
        },

        /**
         * Handle search users by keyword.
         */
        onInputKeyup: _.throttle(function( e ) {
            if ( ! this.shadowInput ) {
                this.shadowInput = this.$el.querySelector( '.joms-input--shadow' );
            }

            this.shadowInput.innerHTML = e.target.value;
            this.inputWidth = this.shadowInput.clientWidth + 20;
            this.search( e.target.value.trim() );
        }, 50 ),

        /**
         * Handle select user.
         * @param {number} id
         */
        onSelect: function( id ) {
            this.select( +id );
        }

    }
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],5:[function(require,module,exports){
(function (global){
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null),
    Vue = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vue,
    ChatbarWindowSearch = require( './chatbar-window-search' ),
    ChatbarWindowInput = require( './chatbar-window-input' ),
    user_id = String( window.joms_my_id || '' ),
    settings = window.joms_plg_jomsocialchatbar || {},
    templates = settings.templates || {},
    moment = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).moment;;

module.exports = Vue.component( 'chatbar-window', {
    template: templates.chatbar_window,

    components: {
        ChatbarWindowSearch: ChatbarWindowSearch,
        ChatbarWindowInput: ChatbarWindowInput,
    },

    props: [ 'chat' ],

    data: function() {
        var participants = JSON.parse( JSON.stringify( this.chat.users ) );
        return {
            setting: false,
            adding: false,
            loading: false,
            myId: user_id,
            participants: participants,
            scrollTop: 0,
            currentHeight: 0,
            initData: false,
            fetchDone: false,
            scrollPosition: 'bottom'
        };
    },

    mounted: function() {
        this.initializeData();
    },

    computed: {
        active : function() {
            return this.$store.state.chats.active == this.chat.id;
        },

        dgroups: function() {
            var chats = this.$store.state.chats.info,
                chatid = this.chat.id,
                messagesX,
                grouped = [],
                dateIndexPrev, 
                userIndexPrev;
            
            if ( chats[this.chat.id] ) {
                messagesX = this.$store.state.chats.messages.filter( function( item ) {
                    return +item.chat_id === +chatid;
                });

                for ( var i = 0; i < messagesX.length; i++) {
                    var message = messagesX[i],
                        date = new Date( message.created_at * 1000 ),
                        dateIndex = date.toJSON().slice( 0, 10 ).replace( /-/g, '' ),
                        userIndex = String( message.user_id ),
                        dateFormatted = this.formatDate( date.getTime() ),
                        timeFormatted = this.formatTime( date.getTime() ),
                        messages;

                    if ( message.action === 'seen' ) {
                        continue;
                    }

                    // parse object at first load
                    if ( typeof message.attachment === 'string' ) {
                        message.attachment = JSON.parse(message.attachment);
                    }

                    message.params = _.isObject(message.params) ? message.params : ( message.params ? JSON.parse(message.params) : {} );

                    if ( dateIndex !== dateIndexPrev ) {
                        dateIndexPrev = dateIndex;
                        userIndexPrev = undefined;

                        grouped.push({
                            date: dateIndex,
                            dateFormatted: dateFormatted,
                            messages: []
                        });
                    }

                    messages = grouped[ grouped.length - 1 ].messages;
                    if ( message.action !== 'sent' ) {
                        userIndexPrev = undefined;
                        messages.push({
                            info: message.action,
                            messages: []
                        });
                    } else if ( userIndex !== userIndexPrev ) {
                        userIndexPrev = userIndex;
                        messages.push({
                            user: userIndex,
                            messages: []
                        });
                    }

                    messages = messages[ messages.length - 1 ].messages;
                    messages.push( _.extend({}, message, {
                        timeFormatted: timeFormatted
                    }) );

                }
            }
            return grouped;
        },

        oldestMsg: function() {
            var self = this,
                messages  = this.$store.state.chats.messages,
                ids, chatMsg, oldest;

            chatMsg = messages.filter( function( item ) {
                return +item.id && +item.chat_id === +self.chat.id;
            }); 

            ids = chatMsg.map( function( item ) {
                return +item.id;
            });

            if ( ids.length ) {
                oldest = ids.reduce( function( a, b) {
                    return Math.min( a, b);
                })
                return oldest;
            } else {
                return 0;
            }
        },

        seenBy: function() {
            var self = this;

            if (self.chat.seenBy && +joms.getData('chat_enablereadstatus')) {
                var users = self.$store.state.users;
                
                return self.chat.seenBy.filter( function( id ) {
                    return users[ id ] && +id != +self.myId;
                }).map( function( id ) {
                    return users[ id ].name;
                })

            } else {
                return [];
            }
        },

        seenUsers: function() {
            if ( this.seenBy.length ) {
                return this.seenBy.join( '<br>' );
            } else {
                return '';
            }
        },

        seenText: function() {
            return Joomla.JText._('PLG_JOMSOCIALCHATBAR_SEEN');
        }
    },

    beforeUpdate: function() {
        this.scrollHeightBeforeUpdate = this.$el.querySelector( '.joms-js-scrollable' ).scrollHeight;
    },

    updated: function () {
        var container = this.$el.querySelector('.joms-js-scrollable'),
            scrollHeight;
            
        if (!this.active) {
            this.setting = false;
        }
        
        if (this.initData) {
            container.scrollTop = container.scrollHeight;
            this.initData = false;
            return;
        } 

        if (this.scrollHeightBeforeUpdate != container.scrollHeight && this.scrollPosition === 'top') {
            scrollHeight = Math.abs( container.scrollHeight - this.scrollHeightBeforeUpdate );
            container.scrollTop = scrollHeight;
            this.scrollPosition = 'middle';
            return;
        } 

        if (this.scrollPosition === 'bottom') {
            container.scrollTop = container.scrollHeight;
            return;
        }
    },

    methods: {
        add: function() {
            this.setting = false;
            this.adding = true;
        },

        leave: function() {
            this.setting = false;
            if ( confirm( Joomla.JText._('PLG_JOMSOCIALCHATBAR_ARE_YOU_SURE_TO_LEAVE_THIS_CONVERSATION') ) ) {
                this.$store.dispatch( 'chats/leave', this.chat.id );
            }
        },

        toggle: function() {
            this.$store.dispatch( 'chats/toggle', this.chat.id );
            this.setActive(this.chat);
        },

        toggleSetting: function( status ) {
            if ( status === 'hide' ) {
                this.setting = false;
            } else {
                this.setting = !this.setting;
            }
        },

        close: function() {
            this.$store.dispatch( 'chats/close', this.chat.id );
        },

        initializeData: function( direction ) {
            var self = this,
                chatid = self.chat.id,
                payload = { id: this.chat.id, oldestMsg: this.oldestMsg };

            if (self.chat.initialized) {
                self.initData = true;
                return;
            }

            self.loading = true;

            self.$store.dispatch( 'chats/messages/fetch', payload ).then( function( data ) {
                self.loading = false;
                self.initData = true;
                self.$store.dispatch('chats/initialized', { id: +chatid});
                if ( data.seen.length ) {
                    data.seen.forEach( function( item ) {
                        self.$store.dispatch( 'chats/seenBy', { chatid: +item.chat_id, userid: +item.user_id } );
                    })
                }
            });
        },

        loadOlderMessages: function() {
            var self = this,
                chatid = self.chat.id,
                store = self.$store,
                payload = { id: self.chat.id, oldestMsg: self.oldestMsg };

            if ( self.loading ) {
                return;
            }

            self.loading = true;

            store.dispatch( 'chats/messages/fetch', payload ).then( function( data ) {
                self.loading = false;
                if ( data.messages.length === 0 ) {
                    self.fetchDone = true;
                }
            });
        },

        handleScroll: function (e) {
            var container = this.$el.querySelector('.joms-js-scrollable');

            if (!container.scrollTop) {
                this.scrollPosition = 'top';
            } else if (container.scrollTop === (container.scrollHeight - container.clientHeight)) {
                this.scrollPosition = 'bottom';
            } else {
                this.scrollPosition = 'middle';
            }

            if (this.scrollPosition === 'bottom' && this.active && !this.chat.seen) {
                this.$store.dispatch('chats/seen', +this.chat.id);
            }
        },

        handleWheel: function( e ) {
            var el = e.currentTarget,
                scrollTop = el.scrollTop,
                delta = e.deltaY,
                height;

            if ( scrollTop === 0 && delta < 0 ) {
                e.preventDefault();

                if ( this.fetchDone ) {
                    return false;
                }

                this.loadOlderMessages();
            } else {
                height = el.scrollHeight - el.clientHeight;
                if ( Math.abs( scrollTop - height ) <= 1 && delta > 0 ) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }
        },

        replaceLink: function( value ) {
            return value.replace( /((http|https):\/\/.*?[^\s]+)/g,
                '<a target="_blank" style="text-decoration:underline" href="$1">$1</a>' );
        },

        replaceNewline: function( value ){
            return value.replace( /\\n/g, '<br />' )
                .replace( /\r?\n/g, '<br />' );
        },

        getName: function( id ) {
            return this.$store.getters[ 'users/name' ]( id );
        },

        replaceEmoticon: function( str ) {
            var emoticons = joms.getData('joms_emo'),
                codes = [],
                names = [];

            _.each( emoticons, function(emo, name) {
                codes.unshift(emo);
                names.unshift(name);
            }) 

            _.each( codes, function( code, idx ) {
                _.each( code, function(c) {
                    str = str.replace(c, '<span class="joms-content-emo2 joms-emo2 joms-emo2-'+names[idx]+'"></span>');
                });
            });

            return str;
        },

        photoZoom: function( url ) {
            joms.api.photoZoom( url );
        },

        addUsers: function( userIds ) {
            var payload;

            this.adding = false;
            if ( userIds && userIds.length ) {
                payload = { chatid: this.chat.id, userids: userIds };
                this.$store.dispatch( 'chats/addUsers', payload );
            }
        },

        submit: function( data ) {
            var store = this.$store,
                chatid = this.chat.id;

            this.scrollPosition = 'bottom';

            store.dispatch( 'chats/messages/submit', {
                id: chatid,
                data: data
            }).then( function() {
                store.dispatch( 'chats/setTopSidebar', chatid );
            });

            store.dispatch( 'chats/clearSeen', { chatid: chatid } );
        },

        mute: function( state ) {
            var action = state ? 'chats/mute' : 'chats/unmute';
            this.$store.dispatch( action, { id: this.chat.id });
        },

        showTooltip: function( e ) {
            var el = $( e.currentTarget ),
                tooltip = el.attr( 'data-tooltip' ),
                position = el.offset();

            if ( ! this.$tooltip ) {
                this.$tooltip = $('<div class="joms-tooltip joms-js-chat-tooltip" />')
                    .appendTo( document.body );
            }

            this.$tooltip.html( tooltip ).show();
            
            if (el.hasClass('joms-chat__messages-seen_status')) {
                this.$tooltip.addClass('joms_chat__seen-tooltip').css({
                    left: position.left,
                    top: position.top - 5,
                    transform: 'translateY(-100%)'
                });
            } else {
                this.$tooltip.removeClass('joms_chat__seen-tooltip').css({
                    left: position.left - this.$tooltip.outerWidth() - 10,
                    top: position.top + ( el.outerHeight() / 2 ),
                    transform: 'translateY(-50%)'
                });
            }

        },

        hideTooltip: function( e ) {
            if ( this.$tooltip ) {
                this.$tooltip.hide();
            }
        },

        setActive: function( chat ) {
            this.$store.dispatch( 'chats/setActiveWindow', +chat.id );
            if ( +chat.seen === 0 && this.scrollPosition === 'bottom' ) {
                this.$store.dispatch( 'chats/seen', +chat.id );
            }
        },

        formatDate: function( timestamp ) {
            var now = moment(),
                date = moment( timestamp ),
                format = 'D MMM';

            if ( now.year() !== date.year() ) {
                format = 'D/MMM/YY';
            }

            return date.format( format );
        },

        formatTime: function( timestamp ) {
            var time = moment( timestamp ),
                format = joms.getData( 'chat_time_format' ) || 'g:i A';

            // PHP-to-Moment time format conversion.
            format = format
                .replace( /[GH]/g, 'H' )
                .replace( /[gh]/g, 'h' )
                .replace( /i/ig, 'mm' )
                .replace( /s/ig, 'ss' );

            return this.formatDate( timestamp ) + ' ' + time.format( format );
        },

        formatName: function (names) {
            if ( ! _.isArray( names ) ) {
                names = [ names ];
            }

            if ( names.length === 1 ) {
                names = names[0];
            } else if ( names.length > 1 ) {
                names = _.map( names, function( str, span ) {
                    // Remove badge on group conversations.
                    if ( str.indexOf( '<' ) >= 0 ) {
                        span = document.createElement( 'span' );
                        span.innerHTML = str;
                        str = span.innerText;
                    }

                    str = str.split( ' ' );
                    return str[0];
                });
                names = names.sort();
                names = names.join( ', ' );
                names = names.replace( /,\s([^\s]*)$/, ' ' + Joomla.JText._('PLG_JOMSOCIALCHATBAR_AND') + ' $1' );
            } else {
                names = '';
            }

            return names;
        }

    }
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./chatbar-window-input":3,"./chatbar-window-search":4}],6:[function(require,module,exports){
(function (global){
var Vue = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vue,
    ChatbarSidebar = require( './chatbar-sidebar' ),
    ChatbarWindow = require( './chatbar-window' ),
    settings = window.joms_plg_jomsocialchatbar || {},
    configs = settings.configs || {},
    templates = settings.templates || {};

module.exports = Vue.component( 'chatbar', {
    template: templates.chatbar,
    components: {
        ChatbarSidebar: ChatbarSidebar,
        ChatbarWindow: ChatbarWindow
    },
    data: function() {
        var data = { 
            position: 'right',
            limitOpened: 0 
        };

        if ( configs.chat_bar_position ) {
            data.position = configs.chat_bar_position;
        }

        return data;
    },
    mounted: function() {
        this.setLimitOpened();
        window.addEventListener( 'resize', this.setLimitOpened );
    },
    computed: {
        openedChats: function() {
            var store = this.$store,
                getter = store.getters[ 'chats/opened' ],
                opened = getter.opened,
                needClose = getter.needClose;

            _.each( needClose, function( id ) {
                store.dispatch( 'chats/close', id );
            });

            return opened;
        }
    },

    methods: {
        setLimitOpened: function() {
            this.$store.dispatch( 'chats/setLimitOpened' );
        }
    } 
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./chatbar-sidebar":2,"./chatbar-window":5}],7:[function(require,module,exports){
function formatName( names ) {
    if ( ! _.isArray( names ) ) {
        names = [ names ];
    }

    if ( names.length === 1 ) {
        names = names[0];
    } else if ( names.length > 1 ) {
        names = _.map( names, function( str, span ) {
            // Remove badge on group conversations.
            if ( str.indexOf( '<' ) >= 0 ) {
                span = document.createElement( 'span' );
                span.innerHTML = str;
                str = span.innerText;
            }

            str = str.split( ' ' );
            return str[0];
        });
        names = names.sort();
        names = names.join( ', ' );
        names = names.replace( /,\s([^\s]*)$/, ' ' + Joomla.JText._('PLG_JOMSOCIALCHATBAR_AND') + ' $1' );
    } else {
        names = '';
    }

    return names;
}

module.exports = {

    /**
     * Fetch conversation list.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     */
    fetch: function( context, payload ) {
        return jQuery.Deferred( function( defer ) {
            _.each( payload.buddies, function( item ) {
                context.commit( 'users/add', { data: item }, { root: true });
            });

            _.each( payload.conversations, function( item ) {
                item.id = String( item.chat_id );
                item.name = formatName( item.name );
                context.commit('add', item);
            });
        
            _.each( payload.opened, function( item ) {
                item.id = String( item.chat_id );
                item.name = formatName( item.name );

                context.commit('add', item);
            });

            defer.resolve();
        });
    },

    fetchMore: function(context, payload) {
        return jQuery.Deferred( function( defer ) {
            joms.ajax({
                func: 'chat,ajaxInitializeChatData',
                data: [JSON.stringify( payload.list )],
                callback: function(json) {
                    var empty = true;
                    _.each( json.buddies, function( item ) {
                        context.commit( 'users/add', { data: item }, { root: true });
                    });

                    _.each( json.list, function( item ) {
                        item.id = String( item.chat_id );
                        item.name = formatName( item.name );

                        context.commit('add', item);
                        context.commit('addSidebarItem', item.id)
                        empty = false;
                    });
                    
                    if ( empty ) {
                        defer.reject();
                    } else {
                        defer.resolve();
                    }
                }
            });
        });
    },

    initialized: function (context, payload) {
        context.commit('initialized', payload);
    },

    /**
     * Check updates on conversation state.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @return {jQuery.Deferred}
     */
    check: function( context ) {
        var opened = _.map( context.getters[ 'opened' ], function( item ) {
            return item.id;
        });

        return context.dispatch( 'messages/check', { ids: opened });
    },

    /**
     * Open a conversation.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {number} id
     */
    open: function( context, id ) {
        var chat = context.state.info[id];
        if ( chat ) {
            context.commit( 'open', id );
            context.commit( 'storeState' );
        }
    },

    /**
     * Close a conversation.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {number} id
     */
    close: function( context, id ) {
        var chat = context.state.info[id];
        if ( chat && chat.open ) {
            context.commit( 'close', id );
            context.commit( 'storeState' );
        }
    },

    /**
     * Toggle a conversation.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {number} id
     */
    toggle: function( context, id ) {
        var chat = context.state.info[id];
        if ( chat && chat.open ) {
            context.commit( 'toggle', id );
            context.commit( 'storeState' );
        }
    },

    /**
     * Leave a conversation.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {number} id
     */
    leave: function( context, id ) {
        joms.ajax({ 
            func: 'chat,ajaxLeaveChat', 
            data: [ id ],
            callback: function() {
                context.commit( 'delete', id );
            } 
        });
    },

    /**
     * Add users to the conversation.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {Object} payload
     * @param {number} payload.id
     * @param {number[]} payload.users
     */
    addUsers: function( context, payload ) {
        var chatid = payload.chatid,
            userids = payload.userids;

        userids = _.map( userids, String );
        userids = JSON.stringify( userids );

        context.commit('addUsers', payload);
        joms.ajax({
            func: 'chat,ajaxAddPeople',
            data: [ chatid, userids ],
            callback: function() {
                context.commit('addUsers', payload);
            }
        });    
    },

    /**
     * Mute conversation.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {Object} payload
     * @param {number} payload.id
     */
    mute: function( context, payload ) {
        var id = payload.id;

        context.commit( 'mute', id );
        joms.ajax({ func: 'chat,ajaxMuteChat', data: [ id, 1 ] });
    },

    /**
     * Unmute conversation.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {Object} payload
     * @param {number} payload.id
     */
    unmute: function( context, payload ) {
        var id = payload.id;

        context.commit( 'unmute', id );
        joms.ajax({ func: 'chat,ajaxMuteChat', data: [ id, 0 ] });
    },

    seen: function( context, id ) {
        return jQuery.Deferred( function( defer ) {
            joms.ajax({
                func: 'chat,ajaxSeen',
                data: [id],
                callback: function() {
                    context.commit( 'seen', id );
                    defer.resolve();
                }
            });
        });
    },

    seenBy: function( context, payload ) {
        if ( payload.userid != window.joms_my_id ) {
            context.commit( 'seenBy', payload );
        }
    },

    clearSeen: function( context, payload ) {
        context.commit( 'clearSeen', payload );
    },

    unread: function( context, id ) {
        context.commit( 'unread', id );
    },

    syncState: function ( context ) {
        context.commit( 'syncState' );
    },

    setTopSidebar: function ( context, id ) {
        context.commit( 'setTopSidebar', id );
    },

    addSidebarItem: function ( context, id ) {
        context.commit( 'addSidebarItem', id);
    },

    setActiveWindow: function ( context, id ) {
        context.commit( 'setActiveWindow', id );
    },

    setLimitOpened: function( context ) {
        var body_width = document.body.clientWidth,
            sidebar_width = 220,
            left_space = 20,
            limit = 0;

        limit = parseInt(( body_width - sidebar_width - left_space - 60 ) / 240);
        context.commit( 'setLimitOpened', limit );
    },

    changeName: function( context, payload ) {
        context.commit( 'changeName', payload );
    }

};

},{}],8:[function(require,module,exports){
(function (global){
var localStorage = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).storage;

module.exports = {

    opened: function( state, getters ) {
        var opened = [],
            needClose = [],
            limit = state.limitOpened,
            active = state.active,
            idx;

        if ( limit ) {
            var chats = _.filter( state.opened, function( id ) {
                return state.info[id];
            });

            if ( chats.length > limit  && limit ) {
                _.each( chats.splice( limit ), function( id ) {
                    if ( id != active) {
                        needClose.push( id );    
                    }
                });

                idx = chats.indexOf( active ); 
                if ( active && idx === -1 ) {
                    needClose.push( chats.pop() );
                    chats.push( active );
                }
            }

            _.each( chats, function( id ) {
                if ( state.info[id] ) {
                    opened.push( state.info[id] );
                }
            });
        } else {
            needClose = state.opened;
        }

        return {
            opened: opened,
            needClose: needClose
        }
    },

    sidebar: function( state, getters) {
        var sidebar = [];
        _.each( state.sidebar, function ( id ) {
            if (state.info[id]) {
                sidebar.push(state.info[id]);
            }
        });

        return sidebar;
    }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],9:[function(require,module,exports){
module.exports = {
    namespaced: true,
    state: require( './state' ),
    getters: require( './getters' ),
    mutations: require( './mutations' ),
    actions: require( './actions' ),
    modules: {
        messages: require( './messages' )
    }
};

},{"./actions":7,"./getters":8,"./messages":12,"./mutations":15,"./state":16}],10:[function(require,module,exports){
module.exports = {

    /**
     * Fetch messages for a conversion.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {Object} payload
     * @param {number} payload.id
     * @return {jQuery.Deferred}
     */
    fetch: function( context, payload ) {
        return jQuery.Deferred(function( defer ) {
            var chatid = payload.id,
                offset = payload.oldestMsg,
                seen = 0,
                params = [ chatid, offset, seen ];

            joms.ajax({
                func: 'chat,ajaxGetLastChat',
                data: params,
                callback: function( json ) {
                    var messages = []; 
                    if ( _.isArray( json.messages ) && json.messages.length ) {
                        _.each( json.messages, function( message ) {
                            messages.push( message );
                        })
                    }

                    if ( _.isArray( json.seen) && json.seen.length ) {
                        _.each( json.seen, function( item ) {
                            messages.push( item );
                        });
                    }
                    
                    messages.sort( function( a, b) {
                        return +b.id - +a.id;
                    });

                    if ( messages.length ) {
                        context.commit( 'append', { messages: messages } );
                    }

                    // Let caller know that the action is complete.
                    defer.resolve( { messages: messages, seen: json.seen } );
                }
            });
        });
    },

    /**
     * Submit message for a conversation.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {Object} payload
     * @param {number} payload.id
     * @param {Object} payload.data
     * @return {jQuery.Deferred}
     */
    submit: function( context, payload ) {
        return jQuery.Deferred(function( defer ) {
            var chatId = payload.id,
                data = payload.data,
                attachment = data.attachment || {},
                timestamp = ( new Date ).getTime(),
                messageId = 'temp_' + timestamp;

            // Assign temporary id to the message.
            data = _.extend({}, data, { id: messageId });

            // Add temporary message.
            context.commit( 'prepend', { messages: [ data ] });

            // Sanitize attachment parameter
            if ( attachment.type && attachment.id ) {
                attachment = { type: attachment.type, id: attachment.id };
            } else {
                attachment = {};
            }

            // Submit actual message.
            joms.ajax({
                func: 'chat,ajaxAddChat',
                data: [ chatId, data.content, JSON.stringify( attachment ) ],
                callback: function( json ) {
                    if ( json.reply_id ) {
                        var item = {
                            tempid: messageId,
                            id: json.reply_id,
                            chatid: json.chat_id
                        }
                        context.commit( 'updateTemp', item );
                        defer.resolve();
                    } else {
                        context.commit( 'error', {tempid: messageId} );
                        json.error && alert(json.error)
                    }
                }
            });
        });
    },

    /**
     * Check new messages for a conversion.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {Object} payload
     * @param {number} payload.id
     * @param {Object} payload.lastMessageId
     * @return {jQuery.Deferred}
     */
    check: function( context, payload ) {
        return jQuery.Deferred(function( defer ) {
            var ids = payload.ids,
                xhr;

            // Sanity check.
            if ( ! ( _.isArray( ids ) && ids.length ) ) {
                defer.resolve();
                return;
            }

            // Get latest messages for each conversations.
            ids = _.map( ids, function( id ) {
                var messages = context.getters[ 'sortedMessages' ]( id ),
                    last;

                if ( messages && messages.length ) {
                    messages = _.filter( messages, function( item ) { return +item.id });
                    last = messages[ messages.length - 1 ];
                    if ( last && +last.id ) {
                        last = +last.id;
                    }
                }

                return [ +id, last || 0 ];
            });

            xhr = joms.ajax({
                func: 'chat,ajaxGetLatestActivities',
                data: [ JSON.stringify( ids ) ],
                callback: function( json ) {
                    if ( json ) {
                        _.each( json, function( messages, chatId ) {
                            _.each( messages, function( item ) {
                                if ( typeof item.attachment === 'string' ) {
                                    item.attachment = JSON.parse( item.attachment );
                                };

                                context.commit( 'add', {
                                    id: chatId,
                                    message: item
                                });
                            });
                        });
                    }

                    defer.resolve();
                }
            });
        });
    }

};

},{}],11:[function(require,module,exports){
module.exports = {
    /**
     * Group oldest message ID of a conversation.
     * @param {Object} state
     * @param {Object} getters
     */
    newestMessageID: function( state, getters ) {
        return function( chatId ) {
            var keys, key;

            if ( state[ chatId ] ) {
                keys = _.chain( state[ chatId ] ).keys()
                    .filter(function( messageId ) { return +messageId })
                    .sortBy(function( messageId ) { return +messageId })
                    .value();

                if ( keys.length ) {
                    key = keys[ keys.length - 1 ];
                }
            }

            return key;
        }
    }

};

},{}],12:[function(require,module,exports){
module.exports = {
    namespaced: true,
    state: require( './state' ),
    getters: require( './getters' ),
    mutations: require( './mutations' ),
    actions: require( './actions' )
};

},{"./actions":10,"./getters":11,"./mutations":13,"./state":14}],13:[function(require,module,exports){
(function (global){
var Vue = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vue;

module.exports = {

    add: function( state, payload ) {
        _.each( payload.data, function( message ) {
            var existed = state.filter( function( item ) {
                return +item.id === +message.id;
            })

            if ( existed.length === 0 ) {
                state.unshift( message );
            }
        })
    },

    append: function( state, payload ) {
        _.each( payload.messages, function( message ) {
            var existed = state.filter( function( item ) {
                return +item.id === +message.id;
            })

            if ( existed.length === 0 ) {
                state.unshift( message );
            }
        })
    },
    prepend: function( state, payload ) {
        _.each( payload.messages, function( message ) {
            var existed = state.filter( function( item ) {
                return +item.id === +message.id;
            })

            if ( existed.length === 0 ) {
                state.push( message );
            }
        })
    },

    updateTemp: function( state, payload ) {

        var temp = state.filter( function( item ) {
            return payload.tempid === item.id;
        })

        if ( temp.length ) {
            _.each( temp, function( msg ) {
                Vue.set( msg, 'id', payload.id );
            })
        }
    },
    error: function( state, payload ) {
        var msg = state.filter( function( item ) {
            return payload.tempid === item.id;
        })

        if ( msg.length ) {
            _.each( msg, function( msg ) {
                Vue.set( msg, 'error', true );
            })
        } 
    }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],14:[function(require,module,exports){
module.exports = [];

},{}],15:[function(require,module,exports){
(function (global){
var Vue = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vue,
    localStorage = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).storage,
    CHATSTATE_MAXIMIZED = 1,
    CHATSTATE_MINIMIZED = 2,
    CHATSTATE_CLOSED = 0;

module.exports = {

    /**
     * Add a new chat.
     * @param {State} state
     * @param {Object} chat
     */
    add: function( state, chat ) {
        if (state.info[chat.id]) {
            _.extend( chat, state.info[chat.id]);
        }
        Vue.set( state.info, chat.id, chat);
    },

    addSidebarItem: function( state, id) {
        if ( state.sidebar.indexOf( +id ) === -1 ) {
            state.sidebar.push( +id ); 
        }
    },

    addUsers: function (state, payload) {
        var chatid = payload.chatid,
            userids = payload.userids,
            chat = state.info[chatid];

        if (chat) {
            userids.forEach(function (id) {
                if (chat.users.indexOf(+id) < 0) {
                    Vue.set(chat, 'participants', +chat.participants + 1 );
                    chat.users.push(+id);
                }
            });
        }   
    },

    initialized: function (state, payload) {
        var chat = state.info[payload.id];
        if (chat) {
            Vue.set( chat, 'initialized', true);
        }
    },

    /**
     * Update an existing chat.
     * @param {State} state
     * @param {Object} payload
     */
    update: function( state, payload ) {
        var id = payload.id,
            chat = payload.chat,
            prevChat = state.info[ id ];

        chat = _.extend({}, prevChat || {}, chat );
        Vue.set( state.info, id, chat );
    },

    /**
     * Remove an existing chat.
     * @param {State} state
     * @param {number} id
     */
    delete: function( state, id ) {
        if ( state.info[id] ) {
            Vue.delete( state.info, id );
        }

        Vue.set( state, 'active', 0 );
    },

    /**
     * Open a chat.
     * @param {State} state
     * @param {number} id
     */
    open: function( state, id ) {
        var info = state.info[id],
            idx = state.opened.indexOf( +id );

        if ( idx === - 1 ) {
            state.opened.push(+id);
        }
        
        if (  info && info.open !== 1 ) {
            Vue.set( state.info[id], 'open', CHATSTATE_MAXIMIZED );
        }
    },

    /**
     * Close a chat.
     * @param {State} state
     * @param {number} id
     */
    close: function( state, id ) {
        var info,
            chatbarState,
            chatState,
            idx = state.opened.indexOf(+id);

        if (idx != -1) {
            state.opened.splice(idx, 1);
        }

        if ( state.info[id] ) {
            info = state.info[id];

            Vue.set( info, 'open', CHATSTATE_CLOSED );
            
        }
    },

    /**
     * Toggle a chat.
     * @param {State} state
     * @param {number} id
     */
    toggle: function( state, id ) {
        var info = state.info[id],
            chatbarState,
            chatState,
            openedState;

        if ( info ) {
            openedState = info.open === CHATSTATE_MINIMIZED ? CHATSTATE_MAXIMIZED : CHATSTATE_MINIMIZED;
            Vue.set( state.info[id], 'open', openedState );
        }
    },

    /**
     * Mute a chat.
     * @param {State} state
     * @param {number} id
     */
    mute: function( state, id ) {
        var info;

        _.each( state.info, function(item) {
            if (item.id == id) {
                info = item;
            }
        })

        if ( info ) {
            Vue.set( info, 'mute', 1 );
        }
    },

    /**
     * Unmute a chat.
     * @param {State} state
     * @param {number} id
     */
    unmute: function( state, id ) {
        var info;

        _.each( state.info, function(item) {
            if (item.id == id) {
                info = item;
            }
        })

        if ( info ) {
            Vue.set( info, 'mute', 0 );
        }
    },

    seen: function( state, id ) {
        var chat = state.info[ id ];
        if (chat) {
            Vue.set( chat, 'seen', 1 );
        }
    },

    seenBy: function( state, payload ) {
        var userid = payload.userid,
            chatid = payload.chatid,
            chat = state.info[ chatid ];
        if ( !chat ) {
            return;
        }

        if ( !chat.seenBy ) {
            Vue.set( chat, 'seenBy', [] );
        }

        chat.seenBy.push( userid );    
    },

    clearSeen: function( state, payload ) {
        var chatid = payload.chatid,
            chat = state.info[ chatid ];
        if ( !chat ) {
            return;
        }

        if ( chat.seenBy ) {
            chat.seenBy.splice( 0, chat.seenBy.length )
        }
    },

    unread: function( state, id ) {
        var chat = state.info[id];
        Vue.set( chat, 'seen', 0 );
    },

    storeState: function ( state ) {
        var chatbarState = localStorage.get('chatbar') || {},
            info = chatbarState.info || {};

        _.each( state.info, function(item) {
            if (typeof item.open !== 'undefined' ) {
                info[item.id] = {};
                info[item.id].open = item.open;
            }
        });
        
        chatbarState.info = info;
        chatbarState.opened = state.opened;
        localStorage.set('chatbar', chatbarState);
    },

    syncState: function ( state ) {
        var chatbarState = localStorage.get( 'chatbar' ) || {},
            info = chatbarState.info || {},
            opened = chatbarState.opened || [];

        _.each( info, function(item, key) {
            if (state.info[key]) {
                Vue.set(state.info[key], 'open', item.open);
            } 
        });

        _.each( opened, function (id) {
            if ( state.opened.indexOf( +id ) === -1 ) {
                state.opened.push(id);
            }
        });
    },

    setTopSidebar: function ( state, id ) {
        var idx = state.sidebar.indexOf( +id );
        if ( idx !== - 1 ) {
            state.sidebar.splice( idx, 1 );
            state.sidebar.unshift ( +id );
        } else if ( state.info[id] ) {
            state.sidebar.unshift( +id );
        }
    },

    setActiveWindow: function ( state, id ) {
        var chat = state.info[id];
        if ( chat && chat.open === CHATSTATE_MAXIMIZED) {
            Vue.set( state, 'active', +id );
        } else {
            Vue.set( state, 'active', 0 );
        }
    },

    setLimitOpened: function( state, limit ) {
        Vue.set( state, 'limitOpened', +limit);
    },

    changeName: function( state, payload ) {
        var chat = state.info[payload.chat_id];

        if (chat) {
            Vue.set( chat, 'name', _.escape( payload.groupname ) );
        }
    }

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],16:[function(require,module,exports){
module.exports = {
    info: {},
    sidebar: [],
    opened: [],
    active: 0,
    limitOpened: 0
};

},{}],17:[function(require,module,exports){
(function (global){
var Vuex = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vuex;

module.exports = new Vuex.Store({
    modules: {
        users: require( './users' ),
        chats: require( './chats' )
    }
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./chats":9,"./users":20}],18:[function(require,module,exports){
module.exports = {};

},{}],19:[function(require,module,exports){
module.exports = {

    /**
     * Get name of particular user.
     * @param {Object} state
     * @param {Object} getters
     */
    name: function( state, getters ) {
        return function( userId ) {
            var name;

            if ( state[ userId ] ) {
                name = state[ userId ].name
            }

            return name;
        }
    },

    /**
     * Get avatar image of particular user.
     * @param {Object} state
     * @param {Object} getters
     */
    avatar: function( state, getters ) {
        return function( userId ) {
            var avatar;

            if ( state[ userId ] ) {
                avatar = state[ userId ].avatar
            }

            return avatar;
        }
    },

    /**
     * Search users by keyword.
     * @param {Object} state
     * @param {Object} getters
     */
    search: function( state, getters ) {
        return function( keyword ) {
            keyword = ( keyword || '' ).trim().toLowerCase();
            return _.filter( state, function( user ) {
                return keyword && ( user.name || '' ).toLowerCase().indexOf( keyword ) !== -1;
            });
        }
    }

};

},{}],20:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./actions":18,"./getters":19,"./mutations":21,"./state":22,"dup":12}],21:[function(require,module,exports){
(function (global){
var Vue = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vue;

module.exports = {

    /**
     * Add a new user.
     * @param {State} state
     * @param {Object} payload
     * @param {Object} payload.data
     */
    add: function( state, payload ) {
        var userData = payload.data,
            userId = userData.id;

        Vue.set( state, userId, userData );
    },

    /**
     * Edit a user.
     * @param {State} state
     * @param {Object} payload
     * @param {number} payload.id
     * @param {Object} payload.data
     */
    edit: function( state, payload ) {
        var userId = payload.id,
            userData = payload.data,
            prevData = state[ userId ];

        if ( prevData ) {
            userData = _.extend({}, prevData, userData );
            Vue.set( state, userId, userData );
        }
    },

    /**
     * Delete a user.
     * @param {State} state
     * @param {Object} payload
     * @param {number} payload.id
     */
    delete: function( state, payload ) {
        var userId = payload.id,
            messageId = payload.messageId;

        if ( state[ userId ] ) {
            delete state[ userId ];
        }
    }

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],22:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}]},{},[1]);
